# Job Platform - Automated Deployment Guide

## Overview

This document describes the automated deployment process for the Job Platform application to AWS. The deployment uses Terraform for infrastructure provisioning and a comprehensive deployment script for application setup.

## Architecture

- **Single EC2 Instance** (t3.micro) - Runs both frontend and backend via Docker
- **RDS PostgreSQL** (t3.micro) - Managed database with AWS Secrets Manager integration
- **Elastic IP** - Static IP address for consistent access
- **Docker Compose** - Container orchestration for application services

## Prerequisites

### Required Tools
- [Terraform](https://terraform.io) >= 1.0
- [Docker](https://docker.com) (for local testing)
- [AWS CLI](https://aws.amazon.com/cli/) configured with appropriate permissions
- `jq` for JSON processing
- `curl` for health checks

### AWS Permissions Required
- EC2 (create, manage instances, security groups, VPC)
- RDS (create, manage databases)
- IAM (create roles, policies)
- Secrets Manager (read secrets)
- Route 53 (if using custom domain)

### Required Files
- `terraform-minimal/terraform.tfvars` with your configuration
- SSH key pair for EC2 access (generated by Terraform)

## Quick Start

### 1. Configure Terraform Variables

Create `terraform-minimal/terraform.tfvars`:

```hcl
project_name = "job-platform"
environment = "production"
aws_region = "us-east-1"

# Database configuration
db_name = "jobplatform"
db_user = "dbadmin"

# SSH configuration
ssh_public_key = "ssh-rsa YOUR_PUBLIC_KEY_HERE"

# Optional: Domain configuration
domain_name = "" # Leave empty for IP-only access
```

### 2. Deploy Infrastructure

```bash
cd terraform-minimal
terraform init
terraform plan
terraform apply
```

### 3. Deploy Application

```bash
# Return to project root
cd ..

# Run automated deployment
./deploy-automated.sh
```

## Deployment Script Features

The `deploy-automated.sh` script provides:

### ✅ **Fully Automated Process**
- Dynamic IP detection from Terraform
- Automatic environment configuration
- AWS Secrets Manager integration
- Container health checking

### ✅ **Dynamic Configuration**
- CORS origins automatically set to current IP
- Frontend API URL configured for current deployment
- Database credentials retrieved from AWS Secrets Manager
- Environment variables generated per deployment

### ✅ **Error Handling & Recovery**
- Prerequisites checking
- SSH connectivity validation
- Container startup verification
- Deployment testing and validation

### ✅ **Security Best Practices**
- No hardcoded credentials in git
- AWS IAM role-based access
- Encrypted database storage
- Secure secrets management

## Application URLs

After successful deployment:

- **Frontend**: `http://YOUR_EC2_IP:3000`
- **Backend API**: `http://YOUR_EC2_IP:8000`
- **API Documentation**: `http://YOUR_EC2_IP:8000/docs`

## Management Commands

### Check Deployment Status
```bash
# SSH to server
ssh -i terraform-minimal/job-platform-key ubuntu@YOUR_EC2_IP

# Check containers
docker compose -f docker-compose.prod.yml ps

# View logs
docker compose -f docker-compose.prod.yml logs frontend
docker compose -f docker-compose.prod.yml logs backend
```

### Redeploy Application
```bash
# Full redeployment
./deploy-automated.sh

# Quick checks
./deploy-automated.sh --check
```

### Update Application Code
```bash
# After making code changes, simply redeploy
./deploy-automated.sh
```

## Environment Configuration

The deployment script automatically generates environment configuration:

```env
# Example generated .env file on server
NODE_ENV=production
NEXT_PUBLIC_API_URL=http://YOUR_EC2_IP:8000
CORS_ORIGINS=http://YOUR_EC2_IP:3000,http://YOUR_EC2_IP:8000
DB_HOST=your-rds-endpoint.amazonaws.com
DATABASE_URL=postgresql://dbadmin:AUTO_GENERATED_PASSWORD@endpoint:5432/jobplatform
# ... additional configuration
```

## Security Features

### 🔐 **AWS Secrets Manager Integration**
- Database passwords automatically managed
- No credentials stored in code or state files
- Automatic password rotation available

### 🔐 **IAM Role-Based Access**
- EC2 instance uses IAM roles to access secrets
- No AWS credentials stored on instance
- Least privilege access principles

### 🔐 **Network Security**
- RDS in private subnet (not publicly accessible)
- Security groups restrict access appropriately
- Encrypted EBS volumes and RDS storage

## Troubleshooting

### Common Issues

**1. SSH Connection Failed**
```bash
# Check EC2 instance status
cd terraform-minimal
terraform output ec2_public_ip

# Verify SSH key permissions
chmod 600 terraform-minimal/job-platform-key
```

**2. Frontend CORS Errors**
```bash
# Check environment configuration on server
ssh -i terraform-minimal/job-platform-key ubuntu@IP
cat /opt/job-platform/.env | grep CORS_ORIGINS
```

**3. Database Connection Issues**
```bash
# Check RDS status in AWS Console
# Verify security group rules allow EC2 -> RDS communication
```

**4. Container Build Failures**
```bash
# SSH to server and check Docker logs
docker compose -f docker-compose.prod.yml logs
```

### Getting Help

**Script Options:**
```bash
./deploy-automated.sh --help    # Show usage information
./deploy-automated.sh --check   # Verify prerequisites only
```

**Manual Deployment Steps:**
If automated deployment fails, you can deploy manually:
1. SSH to the EC2 instance
2. Upload your code
3. Create `.env` file with correct configuration
4. Run `docker compose -f docker-compose.prod.yml up -d`

## Cost Optimization

This deployment is optimized for minimal cost (~$15-25/month):

- **Free Tier Usage**: EC2 t3.micro and RDS t3.micro eligible
- **No Load Balancer**: Direct instance access saves ~$20/month
- **No NAT Gateway**: Public subnet only saves ~$45/month
- **Efficient Storage**: 30GB EBS with GP2 storage type

## Scaling Considerations

When ready to scale:
1. Add Application Load Balancer
2. Create Auto Scaling Group
3. Move to Multi-AZ RDS
4. Implement proper CI/CD pipeline
5. Add CloudFront CDN

## File Structure

```
├── deploy-automated.sh          # Main deployment script
├── docker-compose.prod.yml      # Production container configuration
├── .env.production             # Environment template
├── terraform-minimal/         # Infrastructure code
│   ├── main.tf                # Core infrastructure
│   ├── outputs.tf             # Terraform outputs
│   ├── variables.tf           # Input variables
│   └── terraform.tfvars       # Your configuration
├── frontend/                  # Frontend application
└── backend/                   # Backend application
```

## Next Steps

1. **Domain Setup**: Configure Route 53 with your domain
2. **SSL Certificates**: Setup Let's Encrypt for HTTPS
3. **Monitoring**: Add CloudWatch monitoring and alerts
4. **Backup Strategy**: Configure automated RDS backups
5. **CI/CD Pipeline**: Automate deployments via GitHub Actions